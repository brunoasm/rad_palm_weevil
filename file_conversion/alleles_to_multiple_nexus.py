#!/usr/bin/env python

#Created by Bruno de Medeiros October 2017
#This script takes as input a *.alleles.loci file generated by ipyRAD
#and outputs to several nexus files, one per locus
#Optionally, it adds populations to species names, if a CSV file
#with columns 'sample' and 'population' are provided
#The goal is to use it as input file to STAR BEAST

import StringIO, argparse, os, pandas, sys
from collections import Counter
import random
from Bio import AlignIO
from Bio.Align import MultipleSeqAlignment
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio.Alphabet.IUPAC import IUPACAmbiguousDNA

#this function parses population files to a dictionary
def parse_pop_file(inpath, ipyrad):
    samp2pop = dict()  
    if ipyrad:
        with open(inpath, 'r') as popfile:
            for line in popfile:
                line = line.split('#')[0]
                try:
                    sample, pop =  line.split()
                except:
                    break
                if not sample or not pop:
                    break
                else:
                    samp2pop[sample] = pop
    else:
        pop_table = pandas.read_csv(inpath)
        for i, row in pop_table.iterrows():
            samp2pop[row['sample']] = row['population']
    return samp2pop
            
def parse_alleles_file(inpath, num_spns):
    matrix_list = []
    with open(inpath, 'r') as allfile:
        temp = ''
        for line in allfile:
            if '//' not in line and line.lstrip('\n'):
                temp = temp + line
            elif not line.rstrip('\n '): #sometimes there are blank lines...
                continue
            else:
                symbol_counter = Counter(line)
                if num_spns is None or (symbol_counter['*'] + symbol_counter['-']) in num_spns: 
                    nchar = int(len(temp.split('\n')[0].split()[-1]))
                    ntaxa = int(temp.count('\n'))
                    temp = str(ntaxa) + '\t' + str(nchar) + '\n' + temp
                    phylip = StringIO.StringIO(temp)
                    matrix_list.append(AlignIO.read(phylip, "phylip-relaxed", alphabet=IUPACAmbiguousDNA()))
                    phylip.close()
                temp = '' #whether or not passes minspns filter, zero temp again
    return matrix_list
                
def add_pop_name(alignment, samp2pop):
    for record in alignment:
        record.id = record.id + '_' + samp2pop[record.id.split('_')[0]]
    return None
        
    


if __name__ == "__main__":

    parser = argparse.ArgumentParser()
    parser.add_argument('input', help = 'path to input file,*.unlinked_snps generated by pyRAD')
    parser.add_argument('-p','--pop-file', help = "path to file with population information, if population name is to be appended. It must be in csv format and contain a column named 'sample' and another named 'population'")
    parser.add_argument('-i','--ipyrad', help = "use this flag to use an ipyrad population file, instead of the standard format", action= "store_true")
    parser.add_argument('-s','--subsample', help = "number of loci to randomly subsample. If ommited, all loci are kept", type = int, default = 0)
    parser.add_argument('-n','--num-snps', help = "number of SNPs to keep a locus (can be a range X-Y). If ommited, all loci are kept", default = 0)
    parser.add_argument('-c','--complete', help = "whether to complete alignments with missing taxa (filling with N)", action="store_true")
    args = parser.parse_args()
    #args = parser.parse_args(['-i','-p','/Volumes/Genomics/Odyssey/2017/RAD_phylogeography/STARBEAST/plant_pops.txt','/Volumes/Genomics/Odyssey/2017/RAD_phylogeography/STARBEAST/plants-cov12-pop1.alleles.loci'])
    
    outname = os.path.basename(args.input).split('.')[0]
    
    #parse number of snps
    if args.num_snps:
        if '-' in args.num_snps:
            s, e = args.num_snps.split('-')
            nsnps = range(int(s), int(e) + 1)
        else:
            nsnps = int(args.num_snps)
    else:
        nspns = None
            
    #get alignments and add population names
    alignments = parse_alleles_file(args.input, nsnps)
    
    if args.pop_file:
        samp2pop = parse_pop_file(args.pop_file, args.ipyrad)
        for alignment in alignments:
            add_pop_name(alignment, samp2pop) 
        
    #subsample loci
    if args.subsample > 0:
        if args.subsample < len(alignments):
            alignments = random.sample(alignments,args.subsample)
        else:
            raise Exception('Number to subsample must be smaller than number of loci available!')
        
    
    #now make output
    try:
        os.makedirs(outname)
    except:
        pass
    
    if args.complete: #add missing species to each alignment
        all_taxa = []
        for alignment in alignments:
            all_taxa.extend([record.id for record in alignment]) #first let's get a list of all taxa in each alignment
        all_taxa = set(all_taxa)
        
        for alignment in alignments:
            this_taxa = set([record.id for record in alignment])
            missing_taxa = all_taxa - this_taxa
            al_len = alignment.get_alignment_length()
            
            if missing_taxa:
                sys.stderr.write('Adding ' + str(len(missing_taxa)) + ' missing taxa\n')
                seqrecs = [SeqRecord(Seq('N' * al_len, IUPACAmbiguousDNA()), id=tx) for tx in missing_taxa]
                seqs_to_add = MultipleSeqAlignment(seqrecs)
                alignment.extend(seqs_to_add)
    
    for i, alignment in enumerate(alignments):
        AlignIO.write(alignment, outname + '/' + outname + '_' + str(i) + ".nex", "nexus")